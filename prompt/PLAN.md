# koreaZinc-node 최적화 및 결함 수정 계획서

> **프로젝트명**: 시각 지능 색차 식별 시스템 (고려아연)
> **작성일**: 2025-11-26
> **분석 대상**: electron.js, main.js, static/js/app.js

---

## 프로젝트 개요

이 시스템은 고려아연의 산업용 검사 모니터링을 위한 Electron 기반 데스크톱 애플리케이션입니다.
엣지 기기(카메라)에서 수집된 이미지를 분석하여 제품의 색차를 식별하고,
실시간으로 양품/불량 판정 결과를 대시보드에 표시합니다.

### 현재 아키텍처
- **Frontend**: HTML/CSS/JavaScript (Chart.js 활용)
- **Backend**: Express.js (Node.js)
- **Desktop**: Electron
- **통신**: REST API + IPC (Inter-Process Communication)

---

## 전체 진행 현황

| 단계 | 구분 | 상태 | 예상 소요시간 |
|------|------|------|---------------|
| Phase 1 | 치명적 보안 취약점 | 대기중 | 약 2시간 |
| Phase 2 | 기능 버그 수정 | 대기중 | 약 1시간 |
| Phase 3 | 시스템 안정성 개선 | 대기중 | 약 1.5시간 |
| Phase 4 | 코드 품질 향상 | 대기중 | 약 2시간 |
| Phase 5 | 성능 최적화 | 대기중 | 약 1시간 |

---

## Phase 1: 치명적 보안 취약점 (우선순위: P0 - 즉시 수정 필요)

### 1.1 JWT 시크릿 키 하드코딩 문제

**현재 상황**:
소스코드 내에 JWT 토큰 생성에 사용되는 비밀키가 문자열로 직접 작성되어 있습니다.
이 키는 "your-secret-key-change-this-in-production"이라는 값으로,
누구나 소스코드를 보면 알 수 있는 상태입니다.

**위험성**:
- 공격자가 이 키를 알면 유효한 JWT 토큰을 임의로 생성할 수 있습니다
- 관리자 권한으로 시스템에 무단 접근이 가능해집니다
- 모든 인증 체계가 무력화됩니다

**해결 방향**:
- 환경 변수를 통해 시크릿 키를 외부에서 주입받도록 변경
- .env 파일을 통한 설정 관리 체계 도입
- 환경 변수가 설정되지 않은 경우 앱 실행을 차단

**영향 범위**: electron.js, main.js

---

### 1.2 관리자 계정 하드코딩 문제

**현재 상황**:
관리자 계정 정보(admin/admin123)가 소스코드에 직접 작성되어 있습니다.
심지어 로그인 화면 HTML에도 "기본 계정: admin / admin123"이라고 표시되어 있어
누구나 이 계정으로 로그인할 수 있습니다.

**위험성**:
- 시스템에 접근할 수 있는 모든 사람이 관리자 권한을 획득할 수 있습니다
- 검사 데이터 조작, 시스템 설정 변경 등 모든 기능에 무단 접근 가능
- 감사 추적(Audit Trail)이 의미없어집니다

**해결 방향**:
- 사용자 계정 정보를 외부 파일(JSON) 또는 데이터베이스로 분리
- 최초 로그인 시 비밀번호 변경을 강제하는 기능 추가
- 로그인 화면에서 기본 계정 힌트 제거

**영향 범위**: electron.js, main.js, static/index.html

---

### 1.3 데이터 수집 API 인증 부재

**현재 상황**:
엣지 기기(카메라)에서 검사 데이터를 전송하는 /api/v1/data/collect 엔드포인트에
아무런 인증 절차가 없습니다. 이 API 주소만 알면 누구나 데이터를 전송할 수 있습니다.

**위험성**:
- 가짜 검사 데이터를 시스템에 주입할 수 있습니다
- 통계 데이터가 조작되어 잘못된 품질 판단을 유발할 수 있습니다
- 대량의 요청으로 서버를 마비시킬 수 있습니다 (DoS 공격)

**해결 방향**:
- 엣지 기기 전용 API 키 인증 시스템 도입
- 등록된 기기 IP만 접근 허용하는 화이트리스트 적용
- 요청 속도 제한(Rate Limiting) 구현

**영향 범위**: electron.js, main.js (Express 라우터)

---

## Phase 2: 기능 버그 수정 (우선순위: P0 - 기능 장애)

### 2.1 모델 업데이트 기능 오류

**현재 상황**:
AI 모델 파일을 엣지 기기로 전송하는 기능에서 변수명 오류가 있습니다.
함수 파라미터로는 'file'을 받지만, 실제 코드에서는 'model_file'이라는
존재하지 않는 변수를 사용하고 있어 이 기능이 작동하지 않습니다.

**증상**:
- 모델 파일 전송 버튼 클릭 시 에러 발생
- "model_file is not defined" 오류 메시지

**영향 범위**: electron.js (api:update-model 핸들러)

---

### 2.2 프론트엔드 전역 변수 미정의

**현재 상황**:
프론트엔드 JavaScript에서 current_stats라는 변수를 참조하고 있지만,
이 변수가 선언되어 있지 않아 특정 상황에서 오류가 발생합니다.

**증상**:
- clearAllData() 함수 호출 시 JavaScript 에러 발생
- 기기 선택 해제 시 화면이 제대로 초기화되지 않음

**영향 범위**: static/js/app.js

---

### 2.3 CSV 내보내기 기능 오류

**현재 상황**:
ZIP 파일로 데이터를 내보내는 기능에서 코드 문법 오류가 있습니다.
콤마(,)가 잘못 배치되어 CSV 데이터 생성 코드가 실행되지 않고 무시됩니다.

**증상**:
- ZIP 파일 다운로드는 되지만 CSV 파일 내용이 비어있거나 손상됨
- 메타데이터 정보가 누락됨

**영향 범위**: electron.js (api:export-zip 핸들러)

---

## Phase 3: 시스템 안정성 개선 (우선순위: P1)

### 3.1 메모리 누수 위험

**현재 상황**:
검사 데이터를 저장하는 배열(inspection_data)에 데이터가 계속 누적됩니다.
삭제하는 로직이 없어서 시스템을 오래 운영하면 메모리가 고갈될 수 있습니다.

**예상 문제**:
- 장시간 운영 시 애플리케이션이 점점 느려짐
- 결국 메모리 부족으로 앱이 강제 종료될 수 있음
- 하루에 수천 건의 검사가 진행되면 며칠 내에 문제 발생 가능

**해결 방향**:
- 최대 저장 건수를 제한하고 오래된 데이터는 자동 삭제
- 또는 인메모리 대신 SQLite 같은 파일 기반 DB 사용 검토

**영향 범위**: electron.js, main.js (inspection_data 배열)

---

### 3.2 타이머(Interval) 누수

**현재 상황**:
엣지 기기에 주기적으로 데이터를 요청하는 setInterval이 기기 추가 시마다 생성됩니다.
그러나 기기를 삭제하거나 앱을 재시작해도 이 타이머들이 정리되지 않습니다.

**예상 문제**:
- 기기를 추가/삭제를 반복하면 불필요한 타이머가 계속 쌓임
- 삭제된 기기에 계속 요청을 보내는 무의미한 동작 발생
- CPU 및 네트워크 리소스 낭비

**해결 방향**:
- 타이머 ID를 관리하는 Map 자료구조 도입
- 기기 삭제 시 해당 타이머도 함께 제거
- 앱 종료 시 모든 타이머 정리

**영향 범위**: electron.js, main.js (periodic_data_request 함수)

---

### 3.3 SSRF(Server-Side Request Forgery) 취약점

**현재 상황**:
사용자가 입력한 device_ip 값을 검증 없이 그대로 HTTP 요청 URL에 사용합니다.
악의적인 사용자가 내부 네트워크 주소를 입력하면 서버가 해당 주소로 요청을 보내게 됩니다.

**위험성**:
- 내부 네트워크의 다른 서비스에 무단 접근 가능
- 내부 시스템 정보 노출
- 방화벽 우회 공격의 발판으로 악용 가능

**해결 방향**:
- device_ip가 등록된 기기 목록에 있는지 검증
- IP 형식 유효성 검사 추가
- 허용되지 않은 IP로의 요청 차단

**영향 범위**: electron.js, main.js (video-feed, reboot 등의 API)

---

## Phase 4: 코드 품질 향상 (우선순위: P2)

### 4.1 중복 코드 통합 필요

**현재 상황**:
electron.js(836줄)와 main.js(837줄)에 거의 동일한 코드가 중복으로 존재합니다.
electron.js는 Electron 앱용, main.js는 순수 Node.js 서버용으로 보이지만,
실제 비즈니스 로직은 95% 이상 동일합니다.

**문제점**:
- 버그 수정이나 기능 추가 시 두 파일을 모두 수정해야 함
- 수정 누락으로 인한 불일치 발생 가능성
- 유지보수 비용 2배 증가

**해결 방향**:
- 공통 로직을 별도 모듈(lib 폴더)로 분리
- electron.js와 main.js는 진입점 역할만 수행
- 인증, 데이터 관리, 기기 관리 등을 각각 모듈화

**영향 범위**: 프로젝트 전체 구조 변경

---

### 4.2 프론트엔드 코드 중복

**현재 상황**:
app.js에서 비디오 피드 URL을 설정하는 코드가 두 번 연속 실행됩니다.
첫 번째 설정이 바로 두 번째 설정으로 덮어씌워져 의미없는 코드가 됩니다.

**문제점**:
- 불필요한 API 호출 발생
- 코드 가독성 저하
- 디버깅 시 혼란 유발

**영향 범위**: static/js/app.js (updateVideoFeedURL, openVideoModal 함수)

---

### 4.3 에러 처리 일관성 부재

**현재 상황**:
에러 발생 시 응답 형식이 API마다 다릅니다.
어떤 곳은 { detail: "..." }, 어떤 곳은 { error: "..." },
또 어떤 곳은 { success: false, message: "..." } 형식을 사용합니다.

**문제점**:
- 프론트엔드에서 에러 처리 로직이 복잡해짐
- 일관된 사용자 경험 제공 어려움
- 로깅 및 모니터링 표준화 어려움

**해결 방향**:
- 공통 에러 응답 형식 정의
- Express 에러 미들웨어 도입
- 표준화된 에러 클래스 구현

**영향 범위**: 모든 API 엔드포인트

---

## Phase 5: 성능 최적화 (우선순위: P3)

### 5.1 동기식 파일 I/O 문제

**현재 상황**:
기기 목록을 저장/불러오는 부분에서 동기식 파일 읽기/쓰기를 사용합니다.
이 작업이 진행되는 동안 Node.js 이벤트 루프가 차단되어
다른 요청을 처리할 수 없습니다.

**문제점**:
- 파일 I/O 중 다른 사용자 요청이 대기 상태에 빠짐
- 응답 지연 발생
- 동시 접속자가 많을 경우 성능 저하 심화

**해결 방향**:
- fs.promises를 사용한 비동기 방식으로 전환
- 또는 앱 시작 시에만 동기식으로 로드하고 이후에는 비동기 사용

**영향 범위**: electron.js (loadDevicesFromFile, saveDevicesToFile)

---

### 5.2 데이터 조회 성능

**현재 상황**:
데이터 조회 시 매번 전체 배열을 순회하면서 필터링합니다.
데이터가 수천, 수만 건으로 늘어나면 조회 성능이 급격히 저하됩니다.

**문제점**:
- 차트 데이터 로딩 시간 증가
- API 응답 시간 증가
- 사용자 경험 저하

**해결 방향**:
- 기기별로 데이터를 분리 저장하여 검색 범위 축소
- 시간 기반 인덱싱 도입
- 자주 조회되는 데이터 캐싱

**영향 범위**: electron.js, main.js (데이터 조회 관련 API)

---

## 작업 체크리스트

### Phase 1 (보안 - 최우선)
- [ ] 1.1 SECRET_KEY 환경 변수 분리
- [ ] 1.2 관리자 계정 외부화
- [ ] 1.3 데이터 수집 API 인증 추가

### Phase 2 (버그 수정)
- [ ] 2.1 model_file 변수명 오류 수정
- [ ] 2.2 current_stats 전역 변수 추가
- [ ] 2.3 CSV 스트림 코드 수정

### Phase 3 (안정성)
- [ ] 3.1 inspection_data 크기 제한
- [ ] 3.2 setInterval 누수 방지
- [ ] 3.3 device_ip SSRF 검증

### Phase 4 (품질)
- [ ] 4.1 코드 모듈화
- [ ] 4.2 프론트엔드 중복 제거
- [ ] 4.3 에러 처리 통일

### Phase 5 (성능)
- [ ] 5.1 비동기 파일 I/O
- [ ] 5.2 데이터 조회 최적화

---

## 변경 이력

| 날짜 | 버전 | 변경 내용 |
|------|------|-----------|
| 2025-11-26 | v1.0 | 최초 계획서 작성 |

---

## 참고 사항

1. **테스트**: 각 Phase 완료 후 반드시 기능 테스트 수행
2. **백업**: 작업 시작 전 현재 코드 백업 권장
3. **순차 진행**: Phase 1 완료 후 Phase 2 진행 (의존성 고려)
4. **문서화**: 모든 변경사항은 CHANGELOG.md에 기록
